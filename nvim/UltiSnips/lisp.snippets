global !p
from ultisnips_helpers import *
endglobal

snippet if "if-statement" i
(if ${1:expression}
	${2:if-true}
	${3:if-false})
endsnippet

snippet case "case-statement" i
(case ${1:expression}
	(${2:key} ${3:consequent})$0)
endsnippet

snippet cond "cond-statement" i
(cond
	(${1:predicate} ${2:consequent})$0)
endsnippet

snippet d "defun"
(defun ${1:funcname} (${2:args})
	${3:body})
endsnippet

snippet m "defmacro"
(defmacro ${1:macroname} (${2:args})
	\`${3:body})
endsnippet

snippet v "defvar"
(defvar *${1:varname}*
	${0:${VISUAL:expression}})
endsnippet

snippet p "defvar"
(defparameter +${1:paramname}+
	${0:${VISUAL:expression}})
endsnippet

snippet c "class"
(defclass ${1:Name} ($2)
	($0))
endsnippet

snippet sl "class slot" w
(${1:attr} :initarg :${2:$1} :${3:accessor} ${4:$1})$0
endsnippet

snippet const "defvar"
(defconstant ${1:CONSTNAME}
	${0:${VISUAL:expression}})
endsnippet

snippet let "let expression"
(let
	((${1:expression}))
	${0:${VISUAL:body}})
endsnippet

snippet mult "multiple-value-bind"
(multiple-value-bind (${1:values}) (${2:expression})
	${0:${VISUAL:body}})
endsnippet

snippet fn "lambda expression" i
(lambda (${1:args}) ${2:expression})
endsnippet

snippet map "map" i
(map ${1:'list} ${2:expression} ${0:${VISUAL:xs}})
endsnippet

snippet mapcar "mapcar" i
(mapcar ${1:s-expression} ${2:xs} ${3:ys})
endsnippet

snippet "redu?c?e?" "map" ri
(reduce ${1:expression} ${0:${VISUAL:xs}})
endsnippet
